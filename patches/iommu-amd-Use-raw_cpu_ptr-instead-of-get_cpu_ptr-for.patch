From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date: Tue, 5 Sep 2017 14:11:41 +0200
Subject: iommu/amd: Use raw_cpu_ptr() instead of get_cpu_ptr() for
 ->flush_queue

get_cpu_ptr() disabled preemption and returns the ->flush_queue object
of the current CPU. raw_cpu_ptr() does the same except that it not
disable preemption which means the scheduler can move it to another CPU
after it obtained the per-CPU object.
In this case this is not bad because the data structure itself is
protected with a spin_lock. This change shouldn't matter however on RT
it does because the sleeping lock can't be accessed with disabled
preemption.

Cc: rt-stable@vger.kernel.org
Cc: Joerg Roedel <joro@8bytes.org>
Cc: iommu@lists.linux-foundation.org
Reported-by: Vinod Adhikary <vinadhy@gmail.com>
Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
---
 drivers/iommu/amd_iommu.c |    4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

--- a/drivers/iommu/amd_iommu.c
+++ b/drivers/iommu/amd_iommu.c
@@ -1909,7 +1909,7 @@ static void queue_add(struct dma_ops_dom
 	pages     = __roundup_pow_of_two(pages);
 	address >>= PAGE_SHIFT;
 
-	queue = get_cpu_ptr(dom->flush_queue);
+	queue = raw_cpu_ptr(dom->flush_queue);
 	spin_lock_irqsave(&queue->lock, flags);
 
 	/*
@@ -1938,8 +1938,6 @@ static void queue_add(struct dma_ops_dom
 
 	if (atomic_cmpxchg(&dom->flush_timer_on, 0, 1) == 0)
 		mod_timer(&dom->flush_timer, jiffies + msecs_to_jiffies(10));
-
-	put_cpu_ptr(dom->flush_queue);
 }
 
 static void queue_flush_timeout(unsigned long data)
